// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file salto/nebula/type/device_metadata.proto (package salto.nebula.type, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Date } from "@saltoapis/type";

/**
 * Metadata contains information about a device. Most metadata is immutable.
 *
 * @generated from message salto.nebula.type.DeviceMetadata
 */
export class DeviceMetadata extends Message<DeviceMetadata> {
  /**
   * Circuit boards present in this device.
   *
   * @generated from field: repeated salto.nebula.type.DeviceMetadata.CircuitBoard circuit_boards = 1;
   */
  circuitBoards: DeviceMetadata_CircuitBoard[] = [];

  constructor(data?: PartialMessage<DeviceMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salto.nebula.type.DeviceMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "circuit_boards", kind: "message", T: DeviceMetadata_CircuitBoard, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceMetadata {
    return new DeviceMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceMetadata {
    return new DeviceMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceMetadata {
    return new DeviceMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceMetadata | PlainMessage<DeviceMetadata> | undefined, b: DeviceMetadata | PlainMessage<DeviceMetadata> | undefined): boolean {
    return proto3.util.equals(DeviceMetadata, a, b);
  }
}

/**
 * Metadata of a circuit board present on a device.
 *
 * @generated from message salto.nebula.type.DeviceMetadata.CircuitBoard
 */
export class DeviceMetadata_CircuitBoard extends Message<DeviceMetadata_CircuitBoard> {
  /**
   * Date manufactured
   *
   * @generated from field: salto.type.Date manufacture_date = 2;
   */
  manufactureDate?: Date;

  /**
   * Hardware serial number, for example, `2.000.0020`
   *
   * @generated from field: string serial_number = 3;
   */
  serialNumber = "";

  /**
   * Firmwares present in this circuit board.
   *
   * @generated from field: repeated salto.nebula.type.DeviceMetadata.CircuitBoard.Firmware firmwares = 4;
   */
  firmwares: DeviceMetadata_CircuitBoard_Firmware[] = [];

  constructor(data?: PartialMessage<DeviceMetadata_CircuitBoard>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salto.nebula.type.DeviceMetadata.CircuitBoard";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "manufacture_date", kind: "message", T: Date },
    { no: 3, name: "serial_number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "firmwares", kind: "message", T: DeviceMetadata_CircuitBoard_Firmware, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceMetadata_CircuitBoard {
    return new DeviceMetadata_CircuitBoard().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceMetadata_CircuitBoard {
    return new DeviceMetadata_CircuitBoard().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceMetadata_CircuitBoard {
    return new DeviceMetadata_CircuitBoard().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceMetadata_CircuitBoard | PlainMessage<DeviceMetadata_CircuitBoard> | undefined, b: DeviceMetadata_CircuitBoard | PlainMessage<DeviceMetadata_CircuitBoard> | undefined): boolean {
    return proto3.util.equals(DeviceMetadata_CircuitBoard, a, b);
  }
}

/**
 * Firmware contains the firmware number and version.
 *
 * @generated from message salto.nebula.type.DeviceMetadata.CircuitBoard.Firmware
 */
export class DeviceMetadata_CircuitBoard_Firmware extends Message<DeviceMetadata_CircuitBoard_Firmware> {
  /**
   * Firmware number, for example '0180'.
   *
   * @generated from field: string number = 1;
   */
  number = "";

  /**
   * Firmware version of a specific firmware number.
   *
   * @generated from field: string version = 2;
   */
  version = "";

  constructor(data?: PartialMessage<DeviceMetadata_CircuitBoard_Firmware>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "salto.nebula.type.DeviceMetadata.CircuitBoard.Firmware";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "number", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeviceMetadata_CircuitBoard_Firmware {
    return new DeviceMetadata_CircuitBoard_Firmware().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeviceMetadata_CircuitBoard_Firmware {
    return new DeviceMetadata_CircuitBoard_Firmware().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeviceMetadata_CircuitBoard_Firmware {
    return new DeviceMetadata_CircuitBoard_Firmware().fromJsonString(jsonString, options);
  }

  static equals(a: DeviceMetadata_CircuitBoard_Firmware | PlainMessage<DeviceMetadata_CircuitBoard_Firmware> | undefined, b: DeviceMetadata_CircuitBoard_Firmware | PlainMessage<DeviceMetadata_CircuitBoard_Firmware> | undefined): boolean {
    return proto3.util.equals(DeviceMetadata_CircuitBoard_Firmware, a, b);
  }
}

